# 深入现代浏览器(第二部分)

## 导航发生了什么

  这是四篇博客的第二篇, 来看看Chrome内部如何工作的. 在上一篇文章中, 我们了解到不同的进程和线程控制着浏览器的不同部分. 在这篇文章中, 我们会对于每一个线程和进程在渲染网站的时候的通信方式, 挖掘的更深.

  让我们看一个简单的使用浏览器的案例: 你输入一个URL地址到浏览器中, 然后浏览器从网络上取回数据, 展示到页面上. 这篇文章中, 重点放到: 用户请求一个网站, 浏览器准备渲染页面, 也就是众所周知的导航.

## 通过浏览器进程开始

  ![图1](https://developers.google.com/web/updates/images/inside-browser/part2/browserprocesses.png)

  图1: 上面浏览器的界面, 下图表示浏览器进程中的UI线程, 网络线程和存储线程都包含在浏览器进程中.

  我们在第一篇文章中总结了, CPU, GPU, 内存和多进程架构, 所有tab页之外的一切都被浏览器进程控制. 浏览器进程有许多的线程, 比如UI线程: 负责描绘按钮以及浏览器中字段的输入, 网络线程: 从互联网中通过使用网络堆栈接受数据, 存储线程: 控制文件的访问或者更多. 当你输入URL到地址栏中的时候, 你的输入操作就是由UI线程所控制的.

## 一个简单的导航

### 第一步: 正在输入

  当一个用户开始往地址栏中输入的时候, 第一个UI线程的询问是: "这是一个搜索匹配, 还是URL?". 在Chrome中, 地址栏也是搜索输入框, 所以UI线程需要通过匹配确认, 是将内容发送给搜索引擎, 还是访问你请求的站点.

  ![图1](https://developers.google.com/web/updates/images/inside-browser/part2/input.png)

  图1: UI线程判断输入的是搜索内容还是URL.

### 第二步: 开始导航

  当一个用户按下Enter键, UI线程初始化一个网络方法来获取站点内容. 加载标志展示在tab的角落, 网络线程通过适当的协议, 例如DNS解析和为请求建立TLS链接.

  ![图2](https://developers.google.com/web/updates/images/inside-browser/part2/navstart.png)

  图2: UI线程通知网络线程导航到mysite.com

  在这点上, 网络线程可能会接受一个服务重定向的头部, 例如HTTP 301. 在这个案例中, 网络线程和UI线程通信的结果是请求重定向, 然后, 另个一URL会被初始化.

### 第三步: 读取响应内容

  ![图3](https://developers.google.com/web/updates/images/inside-browser/part2/response.png)

  图3: 响应的头部确定了类型, 并且payload是真正的数据. 一旦响应体(有效载荷)开始进入, 网络线程就会在必要的时候, 查看流的前几个字节.响应中的Content Type展示了数据的类型, 但那可能已经丢失或者是错误的, [MINI Type介绍](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)介绍在这里. 正如[源码](https://cs.chromium.org/chromium/src/net/base/mime_sniffer.cc?sq=package:chromium&dr=CS&l=5)中评论的那样, 这是一项棘手的任务. 你可以通过阅读评论发现不同的浏览器线程如何处理内容类型和负载对.

  如果响应的内容是一个HTML文件, 然后下一步应该是解析数据到渲染引擎, 但如果这是一个zip文件, 或者一些其他的文件, 那就意味着这是一个下载请求, 所以他们需要解析数据到下载管理.

  ![图4](https://developers.google.com/web/updates/images/inside-browser/part2/sniff.png)

  图4: 如果响应的是一个HTML数据, 网络线程会确认是否来自安全站点.

  这也就是进行[安全浏览](https://safebrowsing.google.com/)检查的地方. 如果主域名和响应的数据似乎已匹配到了恶意站点, 然后网络线程会提醒展示一个危险页面. 此外, [Cross Origin Read Blocking(CORB)](https://www.chromium.org/Home/chromium-security/corb-for-developers)检查为了确保敏感的跨站点数据不会进入到渲染进程中.

### 第三步: 发现一个渲染进程

  一旦所有的检查都完成了, 网络线程变信任浏览器跳转到请求的站点, 然后网络线程告诉UI线程数据已经准备好了, UI线程找到一个渲染进程进行web页面的渲染.

  ![图5](https://developers.google.com/web/updates/images/inside-browser/part2/findrenderer.png)

  图5: 网络线程告诉UI线程寻找渲染进程

  因为网络请求需要几百毫秒才能得到响应, 这个进程就会采取一个优化策略. 当UI线程在第二步中, 发送一个URL请求到网络中, 就已经得知要导航到的网站. 在进行网络请求的同时, UI线程尝试主动的找到或者开始一个渲染进程. 这种方法, 如果所有的结果是预期那样的话, 当网络线程开始接受数据的时候, 一个徐然线程已经在备用位置准备好了. 如果导航的请求的跨域了, 这个备用线程也许不能用, 事实上, 另一个不同的进程也许用得到.

### 第四步: 提供导航

  现在数据和渲染进程都准备好了, 接着IPC会通知浏览器进程给渲染进程一个导航. 它也会传送数据流, 所以渲染进程能够接受HTML数据. 一旦浏览器进程确认获取到了渲染进程的提交记录, 导航就完成了, 文件加载格式化就会开始了.

  此时

### 额外步骤: 初始加载完成

## 导航到不同站点

## 服务工作举例

## 提前导航

## 总结

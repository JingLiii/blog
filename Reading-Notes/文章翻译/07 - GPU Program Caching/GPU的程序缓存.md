# GPU程序缓存

> 翻译文章: [GPU Program Caching](https://docs.google.com/document/d/1Vceem-nF4TCICoeGSh7OMXxfGuJEJYblGXRgN9V9hcE/edit#)

## 总览 / 为什么

  因为有一个沙盒, 每一次加载页面, 我们都会转化, 编译和链接它的GPU着色器. 当然不是每一个页面都需要着色器, 合成器使用了一些着色器, 这些着色器需要为tab选项卡重新渲染. 我们应该去缓存一些之前的缓存程序, 并在重新需要的时候, 直接使用他们.

  我们通过一个GPU缓存完成这项缓存, 这里会使用基于内存, 或者磁盘的缓存来加速这一过程.

## 缓存等级

### 内存缓存(In-Memory Cache)

  由于磁盘的访问时间未知(以及所需要的IPC调用), 二进制中所有命中的缓存都来自内存缓存. 基于磁盘的缓存加载在启动时进行.

> **Key Considerations**

  内存缓存主要存储在GPU的通道管理器中, 所以存储在GPU的生命周期的线程中. 因为这个原因, 我们可以假定在内存缓存的生命周期中, 相同着色器的二进制编码不会改变(驱动程序不会变, 供应商不会变等). 所以 我们的关键在与没有转换的着色器源组成. 因为我们并想要限制秘钥的大小, 我们只需要SHA1hash值对源进行散列.

  当再次启动一个GPU程序(这里包含两个着色器(shaders)), 我们还需要在秘钥(key)中, 包含一个属性位置图, 因为它可以影响而二进制的结果, 并对相同的着色器加以区分. 所以, 我们对两个着色器的sha1, 做了一个SHA1的散列, 并放到了属性图中

### 磁盘缓存(Disk Cache)

  磁盘缓存帮助内存缓存作为一种永久的缓存. 它拥有和内存缓存一样的最大容量, 并且所有的程序缓存到内存缓存的时候, 也会通知内存缓存.

  允许磁盘缓存命中的选项中, 包含一个锁定GPU程序信息, 并在我们继续执行的时候, 异步读取二进制信息. 如果将来任何调用涉及到GPU程序, 那会一直等到异步加载完成. 然而, 因为这是一个普通的模式, 见检查了程序的链接状态后, 立即链接(所以, 程序是在异步执行结束后立即运行的), 让其忽略了这个选项.

> **Key Considerations**

  因为会一直存在磁盘里面, 我们需要包含任何会影响未被转换的着色器的二进制内容. 这包含了对驱动器和可能在chromium中转换器的更改. 所以我们想要包括:
  
* 没有转换的着色器源(untranslated shader  sources)
* 绑定的属性位置图(bound attribute location map)
* glGetString(GL_VENDOR)
* glGetString(GL_RENDERER)
* 驱动器版本号(Driver Version ID)
* 供应商标识(Vender ID)
* Chrome Build # *(打包后的chrome??)

  那是一个GPU程序不能使用的, 只能使用在chrome项目中. 如果磁盘缓存一直在chrome中, 应该没问题.

> **Behavior**

  磁盘缓存需要增加在程序启动时的缓存能力, 才能不造成任何性能问题. 因为磁盘缓存的访问时间未知(事实上仅仅编译和链接一个程序, 比从磁盘读取一个二进制的文件要快), 我们永远不会使用磁盘缓存作为缓存的提供者. 相反, 我们从启动一开始, 就加载来自内存的缓存.

  为了获得最佳的行文, 磁盘缓存需要:

* 启动一开始, 就加载二进制文件
  * 因为二进制大小都在1-20kb左右, 并且我们使用了IPC的方式, 所以我们不能一次性加载全部的
  * 磁盘缓存最坏的情况是, 每个文件都死空的, 所以这不应该阻塞启动, 相反, 我们需要在一个单独的线程上懒加载完成.
  * 应该在我们发送一个IPC之前的的时候, 进行"秘钥兼容性"的检查
* 异步的方式执行缓存的更新/写入(没有读取, 只通过内存缓存保持最新)
* 浏览器清理缓存的时候被删除

  实现的时候, 必须注意启动时的竞争情况, 那里就是合成器使用着色器的地方, 这些着色器可能来磁盘, 也可能不来自磁盘, 这会导致一个问题: 我们应该能够把一些程序标记为, 启动时立即加载吗? 合成器中的着色器使用的数据, 是从磁盘中获取快, 还是进行普通的链接和编译快呢?这是被认为是未来的事情, 尽管有些过头了.

## 回收(Eviction)

### 考虑过程(Considerations)

  源数据加载的时候, 页面中最佳的回收方案是MRU. 这是因为同一份二进制文件无法使用两次, 我们只需要加载一次

### 最后选择(Final choice)

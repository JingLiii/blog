# Java笔记15 - 网络编程

## 网络编程基础

* 计算机网络: 两台或者更多台计算机组成的网络, 在同一个网络中, 任意两台中计算机可以直接通信, 所有计算机都需要遵守同一种网络协议.
* 计算机接入互联网, 必须使用TCP/IP协议
* TCP/IP协议泛指互联网协议, 最重要的两个协议: TCP协议和IP协议

### IP地址

* IP地址用于唯一标识一个网络接口
* IPV4: 采用32位地址; IPV6: 采用128位地址
* `127.0.0.1`: 指向本机
* 公网IP地址和内网IP地址. 公网ip可以直接访问, 内网ip只能内部网络访问`(10.*.*.*)``192.168.*.*`
* 如果有一个网卡, 并接入了网络, 就有了一个本机地址, 和ip地址, 可以使用这个ip地址接入网络
* 如果有两个网卡就可以分别接入不同的网络, 例如路由器和交换机
* 如果两台计算机位于同一个网络, 那么他们可以直接通信, 因为ip地址的前段是相同的, 也就是网络号是相同的.
* 网络号: ip地址通过子网掩码过滤后得到的.

```md
IP = 101.202.99.2
Mask = 255.255.255.0
Network = IP & Mask = 101.202.99.0
```

* 网络号相同, 证明在同一个网路, 可以直接通信
* 网络号不同, 需要路由器/交换机进行通讯. 也就是网关
* 网关的作用是链接多个网络
* 路由: 负责把一个网络的数据包发送到另一个网络

### 域名

* 域名解析服务器DNS负责把域名翻译成对应的IP, 客户端再根据IP访问
* `nslookup [url]`
* `nsloopkup www.baidu.com`

```txt
Server:  192.168.16.1
Address: 192.168.16.1#53

Non-authoritative answer:
www.baidu.com canonical name = www.a.shifen.com.
Name: www.a.shifen.com
Address: 61.135.169.121
Name: www.a.shifen.com
Address: 61.135.169.125
```

### 网络模型

* OSI网络模型为了简化网络各层操作, 提供标准接口便于实现和维护
* 模型从上到下:
  * 应用层: 提供应用程序之间的通讯
  * 表示层: 处理数据格式, 加解密等
  * 会话层: 负责建立和维护会话
  * 传输层: 提供端到端的可靠传输
  * 网络层: 负责根据目标地址选择路由来传输数据
  * 链路层和物理层: 负责把数据进行分片并真正通过物理网络传输
* TCP协议:
  * 应用层; 传输层; IP层; 网络接口层;

### 常用协议

* IP协议: 一个分组协议, 不保证可靠传输
* TCP协议: 建立在IP协议之上, 传输控制协议, 面向链接的协议, 支持可靠传输和双向通信
* ip协议只负责发送数据包, 不保证顺序和正确性;
* tcp协议负责控制数据包传输, 在传输数据之前要先建立连接, 建立链接后才能传输数据, 传输完成后, 断开链接
* tcp通过接受确认, 超时重传等机制保证数据的可靠传输
* tcp允许双向通信, 即通信的双方可以同时发送和接受数据

* tcp协议是应用最广的协议, http和smtp都是建立在tcp协议之上
* udp协议是一种数据报文协议, 无连接协议, 不保证可靠传输. 在通讯前不需要建立连接, 因此传输效率比tcp高, 并比tcp协议简单; 传输的数据, 需要能够忍受丢失.

## TCP编程

* 一个应用程序通过一个Socket建立一个远程连接, Socket内部通过TCP/IP协议把数据传输到网络
* Socket, TCP, 和部分IP的功能由操作系统提供, 不同的编程语言只是提供了对操作系统的简单封装.
* 操作系统抽出Socket接口, 每个应用程序对应不同的Socket, 数据包才能正确地发到对应的应用程序
* socket: ip + 端口号. 小于1024的属于`特权端口`
* 使用Socket进行网络编程的本质, 是两个进程之间的网络通信.
  * 一个进程充当服务器, 主动监听某个指定的端口
  * 一个进程充当客户端, 主动链接服务器的ip地址和指定端口
  * 连接成功后, 服务器和客户端成功建立一个TCP连接, 双方后续就可以随时发送和接受数据
* Socket成功建立后:
  * 服务端socket是指定的ipd地址和指定的端口号
  * 客户端的socket是它所在的计算机的ip地址和一个由操作系统分配的随机端口号.

### 案例运行顺序

1. 启动服务器, 监听端口, 一直查看有没有其他socket访问这个端口的.
2. 有, 便开启一个新的线程 | 客户端链接这个socket
3. 获取socket的输入和输出 | 客户端获取socket的输入和输出
4. 服务器端向socket写入'hello'
5. 客户端读取socket中数据 `[server]: hello`
6. 客户端获取屏幕输入的数据, 并写入socket中
7. 服务器端接受到socket中数据, 修改后, 再次写入socket中
8. 客户端收到socket中数据, 并打印在屏幕上: `ok: ...`

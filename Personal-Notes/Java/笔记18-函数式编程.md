# Java笔记18 - 函数式编程

## 函数式编程

* 一个大型程序调用若干底层函数, 这些函数又可以调用其他函数
* 大任务被一层层拆解并执行
* 函数是面向过程的程序设计的基本单元

* Java不支持单独定义函数, 静态方法视为独立的函数
* 函数式编程归结为面向过程的程序设计

* 计算机: CPU执行计算代码, 条件判断还有调整等指令代码, 汇编是最贴近计算机的语言
* 计算: 数学意义上的计算, 越是抽象的计算, 离计算机硬件越近
* 编程语言约低级, 越解决计算机, 抽象程度低, 执行效率高. C语言
* 编程语言越高级, 越贴近计算, 抽象程度高, 执行效率低. Python

* 函数式编程是抽象程度很高的编程范式, 纯粹的函数式编程语言编写的函数没有任何的变量.
* 因此, 任一函数, 只要输入确定, 输出就是一定确定的. 称为没有副作用
* 允许函数本身作为参数传入另一个函数, 还可以返回一个函数

## lambda基础

* java的实例方法和静态方法, 本质上都相当于过程式语言的函数. 例如C函数:

```c
char* strcpy(char* dest, char* src)
```

* 只不过java的实例方法隐含地传入了一个`this`变量
* 函数式编程把函数作为基本运算单位, 可以接受函数, 可以返回函数.
* 支持函数式编程的编码风格称为`Lambda`表达式

### Lambda表达式

* 参数类型和返回值类型都是由编译器自动推断

### FunctionalInterface

* 单方法接口称之为`FunctionalInterface`, 用注解`@FunctionalInterface`标记

```java
@FunctionalInterface
public interface Callable<V> {
  V call() throws Exception;
}

@FunctionalInterface
public interface Compare<T> {
  int compare(T o1, T o2); // 唯一一个抽象方法, 其他都是`default`和`static`方法
  boolean equals(Object obj); // 这是`Object`定义的方法
  default Comparator<T> reversed() {
    return Collections.reverseOrder();
  }
  default Comparator<T> thenComparing(Comparator<? super T> other) {
    // ...
  }
  // ...
}
```

## 方法引入

  除了Lambda表达式, 可以直接传入方法使用

```java
  public static void main(String[] args) {
    String[] array = new String[] {"Apple", "Orange", "Banana", "Lemon"};
    Arrays.sort(array, Main::cmp); // 直接传入静态方法

    /**
     * String compareTo(String o), 在实际方法调用的时候为
     * `public static int compareTo(this, String o)`
     */
    Arrays.sort(array, String::compareTo); // 直接传入静态方法

    System.out.println(String.join(", ", array));
  }
  static int cmp(String s1, String s2) {
    return s1.compareTo(s2);
  }
```

* *方法引用: 某个方法签名和接口恰好一致, 就可以直接传入方法引用*
* 签名一致: 方法参数一致, 返回类型相同, 两个方法签名一致

### 构造方法引用

```java
public class Main {
  public static void main(String[] args) {
    List<String> names = List.of("Bob", "Alice", "Tim");
//    List<Person> persons = new ArrayList<>();
//    for (String name: names) {
//      persons.add(new Person(name));
//    }
    List<Person> persons = names.stream().map(Person::new).collect(Collectors.toList());
    System.out.println(persons);
  }
  static int cmp(String s1, String s2) {
    return s1.compareTo(s2);
  }
}

class Person {
  String name;
  public Person(String name) {
    this.name = name;
  }
  public String toString() {
    return "Person" + this.name;
  }
}
```

* 构造方法的引用写法: `类名::new`
* 构造方法隐式的返回`this`

### 总结

* `FunctionalInterface`允许传入
  * 接口实现类
  * Lambda表达式(只需要列出参数名, 其他由编译器推断类型)
  * 符合方法签名的静态实例
  * 符合方法签名的实例方法 (实例类型被看作第一个参数类型)
  * 符合方法签名的构造方法 (实例方法被看作返回类型)
* `FunctionalInterface`不强制继承关系, 不需要方法名称相同, 只要求方法参数(类型和数量)与方法返回类型相同, 即认为方法签名相同

# Java笔记13 - 多线程

## 多线程基础

* 现代操作系统都可以同时执行多任务. 多任务就是同时运行多个任务
* CPU执行代码都是一条条执行. 操作系统可以让CPU对多个任务轮流执行

### 进程

* 一个任务是一个*进程*, 例如: 浏览器, 视频播放器
* 进程内部可以同时执行多个子任务: *线程*
* 一个进程可以包含一个或多个线程, 但至少会有一个线程
* 操作系统调用的最小任务单位是线程
* 同一个应用程序可以有多个进程, 也可以有多个线程
* 各种模式:
  * 多进程模式: 每个进程只有一个线程
  * 多线程模式: 一个进程有多个线程
  * 多进程 + 多线程模式

### 进程VS线程

* 多任务可以由多线程实现, 也可以单进程内的多线程, 也可以混合模式
* 多线程相比, 多进程缺点:
  * 进程比线程开销大,
  * 进程间的通信比线程慢, 因为线程间的通信就是读写同一个变量
* 多进程优点:
  * 多进程的稳定性高, 一个进程的崩溃不会影响其他进程
  * 多线程中, 有一个线程崩溃导致整个进程崩溃

### 多线程

* Java语言内置多线程支持
  * 一个Java程序就是一个JVM进程
  * JVM进程用一个主线程启用`main()`方法
  * `main()`方法内部, 可以启用多个线程
  * JVM内部负责垃圾回收其他线程

* Java多线程编程特点:
  * 多线程模型是JAVA程序最基本的并发模型
  * 后续读写网络, 数据库, Web开发等都需要依赖Java多线程模型

## 创建新线程

* 一个线程启动后, 如果什么也不做, 就结束了
* 方法一: `Thread`派生一个自定义类, 复写`run`方法
* 方法二: 创建`Thread`实例时, 传入一个`Runnable`实例
* 多个线程同时运行, 由操作系统调度, 程序本身无法确定线程的调度顺序
* 直接调用`Thread.run()`是无效的, 相当于直接执行java代码主线程
* 可以使用`Thread.setPriority(int n)`: 可以让操作系统调用优先级便高, 但不能保证优先级高的线程一定会先执行
* `Thread.sleep()` 可以让当前线程暂停一段时间

## 线程的状态

* 线程的状态
  * New: 新创建的线程, 尚未执行
  * Runable: 运行中的线程, 正在执行`run()`方法的Java代码
  * Blocked: 运行中的线程, 因为某些操作被阻塞而挂起
  * Waiting: 运行中的线程, 因为某些操作再等待中
  * Timed Waiting: 运行中的线程, 因为执行`sleep()`方法正在计时等待
  * Terminated: 线程已终止, 因为`run()`方法执行完毕

* 线程再执行过程中, 可以在四种状态之间相互相互, 直到线程终止

* 线程终止的原因:
  * 线程正常终止: `run()`方法执行到`return`语句返回
  * 线程意外终止: `run()`方法因为未捕获异常导致线程终止
  * 对某个线程`Thread`实例调用`stop()`方法终止

* `t.join()`等待线程结束再继续执行

## 中断线程

* 中断线程就是其他线程给该线程发一个信号, 该线程收到信号后结束执行`run()`方法
* 在其他线程中对目标线程调用`interrupt()`方法
* 目标线程反复检测自身状态是否未`interrupted`状态, 如果是, 就立刻结束运行
* `interrupt()`仅仅是发出中断请求, 能不能立即中断, 要看具体代码
* 再具体代码中使用`isInterrupted`进行判断
* `t.join()`会让`main`线程进入等待状态
* 如果对`main`线程调用`interrupt()`, `join()`方法, 会立刻抛出`InterruptedException`
* 目标线程只要捕获到`join()`方法抛出的`InterruptedException`, 说明有其他线程对其调用了`interrupt`方法, 通常情况下线程应该立刻结束返回

```java
public class Main {
  public static void main(String[] args) throws InterruptedException {
    Thread t = new MyThread();
    t.start();
    Thread.sleep(100);
    t.interrupt(); // 中断t线程
    t.join(); // 等待t线程终止
    System.out.println("end");
  }
}

class MyThread extends Thread {
  public void run() {
    Thread hello = new HelloThread();
    hello.start(); // hello线程启动
    try {
      hello.join(); // 等待hello线程结束, 一旦t被终止, 就会停止等待, 立刻抛出异常
    } catch (InterruptedException e) {
      System.out.println("interrupted");
    }
    hello.interrupt(); // 中止hello线程, t线程结束前会对hello进行`interrupt`
  }
}

class HelloThread extends Thread {
  public void run() {
    int n = 0;
    while (!isInterrupted()) {
      n++;
      System.out.println(n + "hello");
      try {
        Thread.sleep(100);
      } catch (InterruptedException e) {
        break;
      }
    }
  }
}
```

* 另一个终止的方法: 设置标志位
* 通过`running`标志位停止线程运行

```java
public class Main {
  public static void main(String[] args) throws InterruptedException {
    HelloThread t = new HelloThread();
    t.start();
    Thread.sleep(1);
    t.running = false;
  }

}
class HelloThread extends Thread {
  public volatile boolean running = true;
  public void run() {
    int n = 0;
    while(running) {
      n++;
      System.out.println(n + "hello");
    }
    System.out.println("end!");
  }
}
```

* 存在与线程之间的变量用`volatile`修饰, 确保每个变量都能读到更新后的值

┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
           Main Memory
│                               │
   ┌───────┐┌───────┐┌───────┐
│  │ var A ││ var B ││ var C │  │
   └───────┘└───────┘└───────┘
│     │ ▲               │ ▲     │
 ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─
      │ │               │ │
┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐
      ▼ │               ▼ │
│  ┌───────┐  │   │  ┌───────┐  │
   │ var A │         │ var C │
│  └───────┘  │   │  └───────┘  │
   Thread 1          Thread 2
└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘

* 线程间变量关系
  * 在java虚拟机中变量的值保存再主内存中
  * 线程访问的时候先获取一个副本, 保存在自己的工作内存中
  * 如果线程改变了值, 虚拟机会在某个时刻把修改后的值写回到主内存中
  * *但是时间不确定*
* `volatile`关键字作用:
  * 每次访问变量时, 总是获取内存的最新值
  * 每次修改变量, 立刻回写到主内存
  * *解决了可见性的问题, 当一个线程修改了某个共享变量的值, 其他线程能够立刻看到修改后的值*

## 守护线程

* 守护线程是为其他线程服务的线程.
* 在JVM中, 所有非守护线程都执行完毕后, 无论有没有守护线程, 虚拟机都会自动退出.
* 再`start()`之前调用`setDaemon(true)`将线程变成守护线程
* *在守护线程不能持有任何需要关闭的资源.*
* 例如: 打开文件等, 因为虚拟机退出时, 守护线程没有任何机会来关闭文件, 这会导致数据丢失

## 线程同步

* *如果多个线程同时读写共享变量, 会出现数据不一致的问题*
* 对变量进行读取和写入时, 结果要正确, 必须保证是原子操作.
* 原子操作是指不能被中断的一个或一系列操作.
* 在多线程模型下, 要保证逻辑正确, 对共享变量进行读写时, 必须保证一组指令以原子方式执行.
* **即某一个线程执行时, 其他线程必须等待**

* 通过*加锁*和*解锁*的操作, 保证3条指令总是在一个线程执行期间, 不会有其他线程会进入此指令区间
* 加锁和解锁之间的代码块称之为临界区. 任何时候临界区最多只有一个线程能执行

* 保证一段代码的原子性, 就是通过加锁和解锁实现的.
* 使用关键字`synchronized`对一个对象进行加锁.

```java
      synchronized(Counter.lock) { // 获得锁
        ...
      } // 释放锁
```

* `synchronized`解决了多线程同步访问共享变量变量的正确性问题. 但是性能下降
* 如何使用:
  1. 找出修改共享变量的线程代码块
  2. 选择一个共享实例作为锁
  3. 使用`synchronized(lockObject){...}`
* 无论是否有异常, 都会在代码块结束的时候释放锁
* *获取到的是哪个锁非常重要*

### 不需要synchronized的操作

* 原子操作:
  * 基本类型(`long`和`double`除外)赋值
  * 引用类型赋值
* 单原子操作不需要同步
* *多行赋值语句, 就必须保证是同步操作*

* 巧妙转换, 就不需要同步操作了

```java
class Pair {
  int first;
  int last;
  public void set(int first, int last) {
    synchronized(this) {
      this.first = first;
      this.last = last;
    }
  }
}

class Pair2 {
  int[] pair;
  public void set(int first, int last) {
    int[] ps = new int[] {
        first,
        last
    }; //  这是`ps`方法内部定义的局部变量, 每个线程都会有各自的局部变量, 互补影响, 不需要同步
    this.pair = ps; // 这是一个原子操作
  }
}
```

## 同步方法

* *方法使用`synchronized(this)`进行锁定, 就会针对每次操作进行锁定*
* 如果一个类设计允许多线程正确访问, 这个类就是*线程安全的*
* 只有提供静态方法, 没有成员变量的类, 也是`线程安全的`
* 使用`synchronized`修饰方法, 表示整个方法使用`this`加锁, 就是同步方法
* 静态方法添加, 表示锁住该类的`class`实例

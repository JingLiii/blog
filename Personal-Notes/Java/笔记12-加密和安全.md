# Java笔记 - 加密和安全

* 面对威胁做到
  * 防窃听
  * 防篡改
  * 防伪造
* 编写计算机程序做到:
  * 不要设计山寨的加密算法
  * 不要实现已有的加密算法
  * 不要修改已有的加密算法

## 编码算法

* ASCII编码, 127字符
* 中文使用`Unicode`编码
* 更加全面的是`UTF-8`

### URL编码

* 如果是ASCII编码能表示的, 就不改变
* 如果不是, 先转成`UTF-8`进行表示
* URL编码总是大写
* `URLEncoder`: 对任意字符进行编码
* `URLDecoder`: 进行解码
* URL编码是编码, 不是加密算法, 只是方便浏览器和服务器处理

### Base64编码

* **对二进制数据编码, 表示成文本格式**
* 可以把任意长度的二进制表示成纯文本
* 并且只包含: `A-Z, a-z, +, /, =`字符
* *3字节的二进制按照6bit一组, 用4个int整数表示, 整数用索引对照, 得到字符*
* 6位整数的范围`0-63`
* A-Z: 0-25
* a-z: 26-51
* 0-9: 52-61
* 62表示`+`;63表示`/`
* `=`表示一排的`0`
* 如果不是3的整倍数, 就在末尾添加, 一个或者两个`0x00`, 用1个或者2个`=`表示
* 编码的长度总是4的倍数, 所以不加`=`也可以计算出来: 使用`withoutPadding()`去掉`=`

* `+`, `/`, `=`不适合出现在URL中
* 针对URL的base64: `+`编程`-`, '/'变成`_`
* 有点: 在哪里都能存
* 确定: 原来的长度增加了1/3

## 哈希算法

* 又称: 摘要算法
* **对任意一组输入的数据进行计算, 得到一个固定长度的输出摘要**
* 特点:
  * 相同输入一定得到相同输出
  * 不同的输入大概率得到不同的输出
* 目的: 为了验证数据是否被篡改

* `hashCode()`: 哈希算法, 输入任意字符串, 输出是固定的4字节`int`的整数
* `HashMap()`基于`hashCode()`工作

### 哈希碰撞

* 不同的输入得到了相同的输出
* 碰撞是必然的, 只需要关注碰撞的概率
* 安全的哈希算法:
  * 碰撞率低
  * 不能猜测输出
* 常用的哈希算法:
  * MD5 128bits 16byte
  * SHA-1 160bits 20byte
  * RipeMD-160 160bits 20byte
  * SHA-256 25bits 32byte
  * SHA-512 512bits 64byte

```java
    // 创建一个MessageDigest实例
    MessageDigest md = MessageDigest.getInstance("MD5");
    // 反复调用update输入数据
    md.update("Hello".getBytes("UTF-8"));
    md.update("World".getBytes("UTF-8"));
    // `digest()`获取`byte[]`数组表示的摘要
    byte[] result = md.digest();
    // 转换为16进制的字字符串, 得到md5值
    System.out.println(new BigInteger(1, result).toString(16));
```

### 哈希算法用途

* 防止原始文件被篡改
* 存储用户口令
  * 用户口令使用hash算法之后, 进行存储
* 彩虹表攻击
  * 破解方法: 存储常用口令, 一次性破解
  * 抵御方法: 对每个口令添加随机数, 也就是`加盐`

### SHA-1

* 新的hash算法, 和`MD5`算法使用方法相同
* **MD5因为输入长度较短, 短时间破解是可能的, 不再推荐**

## BouncyCastle

* 提供很多哈希算法和加密算法的第三方库, 例如:`RipeMD16`哈希算法

## 疑问

### .classpath是什么

* `.classpath`文件中去除以下代码, 正常运行

```xml
    <attributes>
      <attribute name="module" value="true"/>
    </attributes>
```

* 否则报错

```shell
Error: Unable to initialize main class com.itranswarp.learnjava.Main
Caused by: java.lang.NoClassDefFoundError: org/bouncycastle/jce/provider/BouncyCastleProvider
```

## Hmac算法

* 加盐的目的是为了防止用户拿到原始口令
* Hmac: 基于密钥的消息认证码算法
* 和某种哈希算法配合使用
* HmacMD5: 带有一个安全的key的MD5, 不用加盐, 本质: 把key混进摘要的算法

```java
    KeyGenerator keyGen = KeyGenerator.getInstance("HmacMD5");
    SecretKey key = keyGen.generateKey();

    // 打印随机生成的key
    byte[] skey = key.getEncoded();
    System.out.println(new BigInteger(1, skey).toString(16));

    Mac mac = Mac.getInstance("HmacMD5");
    mac.init(key);
    mac.update("HelloWorld".getBytes("UTF-8"));
    byte[] result = mac.doFinal();
    System.out.println(new BigInteger(1, result).toString(16));
```

* 具体操作步骤:
  1. 通过`Hmac5`获取`KeyGenerator`
  2. 通过`KeyGenerator`创建一个`SecretKey`实例
  3. 通过名称`HmacMD5`获取`Mac`实例
  4. 用`SecretKey`初始化`Mac`实例
  5. `Mac`实例反复调用`update(byte[])`输入数据
  6. 调用`Mac`实例的`doFinal()`获取最终的哈希值

* 用`SecretKey`恢复`password`: 从`byte[]`数组中恢复
* 恢复`SecretKey`的语句就是: `new SecretKeySpec(hkey, "HmacMD5")`

```java
byte[] hkey = new byte[] {
    106, 70, -110, 125, 39, -20, 52, 56, 85, 9, -19, -72, 52, -53, 52, -45, -6, 119, -63,
    30, 20, -83, -28, 77, 98, 109, -32, -76, 121, -106, 0, -74, -107, -114, -45, 104, -104, -8, 2, 121, 6,
    97, -18, -13, -63, -30, -125, -103, -80, -46, 113, -14, 68, 32, -46, 101, -116, -104, -81, -108, 122,
    89, -106, -109
};
SecretKey key = new SecretKeySpec(hkey, "HmacMD5");
Mac mac = Mac.getInstance("HmacMD5");
mac.init(key);
mac.update("HelloWorld".getBytes("UTF-8"));
byte[] result = mac.doFinal();
System.out.println(Arrays.toString(result));
```

## 对称加密算法

* 加密: 接受密码和明文, 输出密文
* 解密: 接受密码和密文, 输出明文
* 算法概览: 名称/长度/工作模式/填充模式
  * DES:  56/65  ECB/CBC/PCBC/CTR/...  NoPadding/PKCS5Padding/...
  * AES:  128/192/256  ECB/CEC/PCBC/CTR/...  NoPadding/PKCS5Padding/PKCS7Padding/...
  * IDEA  128  ECB  PKCS5Padding/PKCS7Padding/...
* 秘钥长度决定加加密强度
* 工作模式和填充模式, 对称加密算法的参数和格式选择
* *DES密码长度过短, 并不安全*

### 使用AES加密

```java
public static void main(String[] args) throws Exception {
    // 原文
    String message = "Hello, world";
    System.out.println("Message: " + message);

    // 128位密钥: 16 bytes key
    byte[] key = "1234567890acbdef".getBytes("UTF-8");

    // 加密:
    byte[] data = message.getBytes("UTF-8");
    byte[] encrypted = encrypt(key, data);
    System.out.println("Encrypted: " + Base64.getEncoder().encodeToString(encrypted));

    // 解密:
    byte[] decrypted = decrypt(key, encrypted);
    System.out.println("Decrypted: " + new String(decrypted, "UTF-8"));
  }
  
  // 加密:
  public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException {
    Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
    SecretKey keySpec = new SecretKeySpec(key, "AES");
    cipher.init(Cipher.ENCRYPT_MODE, keySpec);
    return cipher.doFinal(input);
  }
  
  // 解密:
  public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException {
    Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
    SecretKey keySpec = new SecretKeySpec(key, "AES");
    cipher.init(Cipher.DECRYPT_MODE, keySpec);
    return cipher.doFinal(input);
  }
```

* 开发步骤:
  1. 根据算法名称/工作模式/填充模式获取`Cipher`实例
  2. 根据算法名称初始化一个`SecretKey`实例, 秘钥必须是指定长度
  3. 使用`SecretKey`初始化`Cipher`实例, 并设置加密或者解密模式
  4. 传入明文或者密文
* AES模式过于简单, 通常使用CBC模式, 需要一个随机数IV参数, 同一份明文, 每次的密文都不同

```java
// 加密:
  public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException {
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
    SecretKey keySpec = new SecretKeySpec(key, "AES");

    // CBC模式需要生成一个16bytes的initialization vector
    SecureRandom sr = SecureRandom.getInstanceStrong();
    byte[] iv = sr.generateSeed(16);
    IvParameterSpec ivps = new IvParameterSpec(iv);

    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivps);
    byte[] data = cipher.doFinal(input);
    return join(iv, data);
  }
  
  // 解密:
  public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException {
    // 把input分割成IV和密文
    byte[] iv = new byte[16];
    byte[] data = new byte[input.length - 16];
    System.arraycopy(input, 0, iv, 0, 16);
    System.arraycopy(input, 16, data, 0, data.length);

    // 解密
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
    SecretKey keySpec = new SecretKeySpec(key, "AES");
    IvParameterSpec ivps = new IvParameterSpec(iv);
    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivps);
    return cipher.doFinal(data);
  }
  
  public static byte[] join(byte[] bs1, byte[] bs2) {
    byte[] r = new byte[bs1.length + bs2.length];
    System.arraycopy(bs1, 0, r, 0, bs1.length);
    System.arraycopy(bs2, 0, r, bs1.length, bs2.length);
    return r;
  }
```

* 在CBC模式下, 需要随机生成一个16字节IV参数, 必须使用`SecureRandom`生成
* 生成一个`IvParameterSpec`, 在调用`Cipher`的一个重载方法, 并传入`IvParameterSpec`

## 口令加密算法

* 用户输入的口令需要使用PBE算法, 采用随机数杂凑计算真正的秘钥, 再进行加密
* PBE作用: 把用户输入的口令和一个安全随机的口令采用杂凑后计算真正的秘钥

# JAVA笔记02

## 面向对象基础

* `class`和`instance`是模板和实例的关系
* `class`定义的`field`, 在每个`instance`中都会含有独立的`field`
* 指向`instance`的变量, 都是引用变量

### 方法

* `field`的修饰符, 由`public`改为`private`后, 不可直接访问, 需要通过`method`进行访问

```java
修饰符 方法返回类型 方法名(方法参数列表) {
  若干方法语句;
  return 方法返回值
}
```

* private方法只允许内部调用

#### this

* 始终指向当前实例
* **如果没有命名冲突可以省略`this`**, 如果有局部优先级更高

#### 方法参数

* 调用方法时, 必须按照参数规则一一传递
* 使用`...`进行可变参数
* 如果0个参数时, 实际接收的是一个空数组
* 基本类型参数的传递是调用值的复制
* 引用类型参数的传递是指针的复制, 改变外边的值会影响到内部值

```java
public class Hello {
    public String name;
    public int age;
    public static void main(String[] args) {
      City bj = new City();
      String n = "aaaaaa";
      bj.setName(n);
      n = "bbbbbb"; // 这里是新开了内存地址, 并不影响指针指向地震
      System.out.println(bj.getName()); // aaaaa
    }
};

class City {
    public String name;
    public String getName () {
      return this.name;
    }
    public void setName(String name) {
      this.name = name;
    }
}
```

### 构造方法

* 方法名就是类型, 没有返回值
* **构造方法没有参数限制**
* 内部可以执行任意语句

```java
public class Hello {
    public String name;
    public int age;
    public static void main(String[] args) {
      City bj = new City("beijing");
      City wh = new City();
      System.out.println(bj.getName()); // aaaaa
      System.out.println(wh.getName());
    }
  };

  class City {
    public String name;
    public City() {
    }
    public City(String name) {
      this.name = name;
    }
    public String getName() {
      return this.name;
    }
    public void setName(String name) {
      this.name = name;
    }
}

```

* 可以根据不同参数, 执行不同构造函数
* 引用类型默认参数`null`, 数值类型`int`默认参数`0`, 布尔类型默认值`false`
* **使用this(...)**可以调用其他构成方法

### 方法重载

* 同名不同参方法, 称为重载

### 继承

* 使用`extend`来实现继承

#### 继承树

* 没有写`extend`默认继承自`Object`
* 子类无法访问父类的`private`的字段和方法

#### protected

* 子类可以访问父类的`protected`的字段和方法
* `protected`修饰符, 把访问权限控制在继承树内

#### super

* `super`表示父类
* 在构造函数中, 需要添加`super()`
* 子类不会继承任何父类的构造方法

#### 向上转型

* `Person p = new Student();`
* 可以向上转型, 转化为更高层次

#### 向下转型

```java
Person p1 = new Student();
if (p1 instanceof Student) Student s = (Student) p1;
```

#### 区分继承和组合

```java
class Student extends Person {
    protected Book book;
    protected int score;
}
```

### 多态

* 方法名相同, 参数或者返回值不同是, `Overload`写一个新方法
* 如果全部相同(方法名, 参数, 返回值), 就是覆写`Override`
* `@Override`用来检查覆写是否成功
* Java中的方法调用是基于在实际运行时的方法调用, 而非变量的声明类型
* 如果再子类中需要调用父类 使用`super`进行调用
* `final`标记的方法不允许被重写

```java
final class Person {
}

class Student extends Person { // The type Student cannot subclass the final class Person
}
```

* final修饰的类, 不能被继承
* final修饰的字段, 初始化后, 不能改变

### 抽象类

* 如果仅仅是为了让子类覆写, 定义抽象方法 `abstract`.

```java
abstract class Person {
  public abstract void run();
}
```

* 只有抽象类才能有抽象方法
* 抽象类无法被实例化
* 子类必须完全覆写所有的抽象方法

### 接口

* 只有抽象方法的抽象类,  可以更改为`interface`
* 接口没有字段, 至于抽象方法, 全部默认为`public abstract`

```java
class Student implements Person, Hello { // 实现了两个interface
    ...
}
```

* 一个类可以继承多个接口
* 接口可以继承接口
* `default`方法, 可以不用所有子类都继承

```java

public class Hello {
  public String name;
  public int age;
  public static void main(String[] args) {
    Person a = new Student();
    a.run();
  }
};

class Man {
}

interface Person {
  String getName();
  default void run() {
    getName();
  }
}

class Student extends Man implements Person {
  @Override
  public String getName() {
    System.out.print("aaa");
    return "aaa";
  }
}
```

* 通过`default`, 可以给接口添加方法, 而不用所有子类都添加方法

#### 总结

* 所有公共逻辑放到`abstract class`中, 具体实现在子类.
* 接口表示更高层次的抽象程度.
* 可以通过先继承, 再使用一个接口,  使用的时候用接口引用, 因为接口比抽象类更抽象

### 静态字段和静态方法

* 静态字段共享一个空间
* 调用实例方法, 必须通过一个实例, 但是静态方法就不用
* 静态方法属于类, 没有`this`关键字
* 静态方法, 经常用于工具类
* 抽象类的静态字段, 必须是`final`

### 包

* 命名空间, 用包(package)名, 进行区分
* **包没有继承关系, java.util和java.util.zip是不同的包，两者没有任何继承关系。**
* 注意包的安放目录.

#### 包作用域

* 位于同一个包作用域的类, 可以访问作用域的字段和方法
* 不用`public`, `protected`, `private`修饰的字段和方法就是包作用域
* 包机制就是为了避免命名冲突

### 作用域

* 定义`public`的`class`, `interface`可以被其他类任意访问
* 定义`public`的`field`, `method`可以被其他类访问, 前提是可以访问到这个类
* 

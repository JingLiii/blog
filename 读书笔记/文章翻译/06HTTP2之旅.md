# HTTP/2之旅

> [Journey to HTTP/2](https://kamranahmed.info/blog/2016/08/13/http-in-depth/)

  距离我上一次通过博客写作以来, 经过了很长的一段安静的时间. 因为一直没有足够的时间投入其中. 直到现在有了一些空闲的时间, 我想利用他们写一些HTTP相关的文章.

  HTTP是一种协议, 每一个web开发者都应该知道他是如何推进整个网络的 并应该清楚的知道他是如何帮助你开发更好的应用.

## 什么是HTTP

  首先, 什么是HTTP? HTTP是一种基于`TCP/IP`的应用层的传输协议, 规定了客户端和服务器端如何进行通信的. 定义了在物联网中是请求和传送的内容. 对于应用层的协议, 我理解的只是一层抽象的协议, 让主机(客户端和服务器)之间的交流标准化, 并且依赖于`TCP/IP`来完成客户端之间的请求和响应.TCP默认使用`80`端口, 也可以使用其他的端口. HTTPS使用过的是`443`端口.

## `HTTP/0.9` 一个班机(开始的协议)(1991)

  第一个HTTP的版本是`HTTP/0.9`在1991年之前推出. 那是一种非常简单的协议, 含有一个简单的被称为`GET`的方法. 如果一个客户端通过访问服务器上的一些网页, 他会发出一个下面这种的简单请求.

```http
GET /index.html
```

  服务器返回的内容如下面展示的

```http
(response body)
(connection closed)
```

  这就是服务器获得的请求, 在响应中返回一个HTML, 只要内容开始传输, 那响应就会关闭. 他是

* 无头响应
* `GET`只是一个请求方法
* 响应一个HTML

  正如你看到的, 协议真的没什么, 除了作为未来发展的一个踏板.

## `HTTP/1.0`-1996

  在1996年, 下一个HTTP版本, 即`HTTP/1.0`版本被开发, 大大超过了上一个版本.

  不同于`HTTP/0.9`只能定义HTML响应, `HTTP/1.0`能够定义其他响应格式, 即图片, 视频文件, 普通文本和其他任何的内容类型. 他增加了更多的方法(即, `HEAD`和`POST`), 请求和响应的格式没有改变, HTTP头部可以在请求和响应都增加, 定义额外的状态码, 引入字符集的支持, 多部分类型, 作者, 缓存, 内容格式化并且支持更多

  下面是一个简单的`HTTP/1.0`的请求和响应看起来大概如此:

  ```http
  GET / HTTP/1.0
  Host: kamranahmed.info
  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS)
  Accept: */*
  ```

  正如你看到的, 通过这个请求, 客户端也可以发送他的个人信息, 支持的响应类型内容. 在`HTTP/0.9`中客户端并没有办法发送这些信息, 因为没有头部.

  对于上面的请求可能有如下的示例响应

  ```http
  HTTP / 1.0 200 OK
  Content-Type: text/plain
  Content-Length: 137582
  Expires: Thu, 05 Dec 1997 16:00:00 GMT
  Last-Modified: Wed, 5 August 1996 15:55:28 GMT
  Server: Apache 0.84

  (response body)
  (connection closed)
  ```

  每一个响应的开始都是`HTTP/1.0`(HTTP后面跟着的是版本号), 然后是状态码`200`, 后面跟着的事原因短语(如果你需要的话, 也可以是对于状态码的描述)

  在这个新的版本中, 请求和响应头, 依旧都是使用`ASCII`进行编码, 但是响应主体可以使用任何类型, 即, 图片, 视频, 普通文本和其他的任何内容类型. 所以, 现在服务器可以发送任何类型的响应给客户端; 在HTTP引入后不久, "超文本"一词, 在`HTTP`中变得并不适用. `HMTP`或者超媒体传输协议也许更加适用于场景, 但是, 我想, 我们还是坚持使用生命这个名字.

  `HTTP/1.0`一个主要的缺点是在每一个链接中使用不同的请求方式. 结果就是, 无论什么时候, 客户端都是为了从服务器获得一些东西, 他会打开一个新的TCP链接, 稍后一个简单的请求会完全使用这个链接. 然后这个链接就关闭了. 无论下一个请求是什么, 都会打开一个新的链接. 为什么坏呢? 很好, 让我们假设, 你浏览的网站有`10`张图片, `5`个样式文件, 和`5`个JavaScript文件, 当网页打开的时候, 需要一共进行20次请求. 因为请求一旦被满足, 服务器就会关闭链接. 将会有一系列独立的20个链接, 每个链接都在自己独立的链接上提供服务. 大量的链接导致严重的性能损失, 因为建立一个新的`TCP`造成明显的性能损失, 因为三次握手的建立启动非常慢.

### 三次握手 (Three-way Handshake)

  三次握手的简单建立过程: 所有的`TCP`链接都是通过三次握手开始的, 也就是客户端和服务器在发送应用数据之前, 发送一系列的数据包.

* `SYN` - 客户端挑选一个随机数, 我们称之为`x`, 然后发送给服务器端.
* `SYN ACK` - 服务器接收到请求之后, 发送一个`ACK`包返回给客户端, 也是一个随机的数字, 我们把服务器选出的数字称之为`y`, 并且和`x+1`, 这里的`x`是通过客户端发送给服务器的.
* `ACK` - 客户端将从服务器收到的数字`y`增加, 返回一个`ACK`的数据包, 包含一个数字`y+1`.

  一次完整的三次握手的过程就完成了, 客户端和服务器端的数据就可以开始传输了. 需要注意的是, 客户端一旦发送完最后一个`ACK`数据包, 就立即开始发送应用数据, 但是服务器端需要等到最后一个`ACK`包接受完成才会去响应请求.

  ![图片](http://i.imgur.com/uERG2G2.png)

> 需要注意, 这张图片有一个严重的问题, 最后一次通过客户端发送的数据包`ACK`, 这次握手应该只包括`y+1`, 也就是, 应该使用`ACK: Y+1`替代`ACK: x+1, y+1`

  然而, `HTTP / 1.0`的一些方案尝试通过增加一个请求头`Connection: keep-alive`去解决这个问题. 那意味着告诉服务器: "你好, 服务器, 不要关闭这个链接, 我还需要它", 但因为没有广泛使用, 所以这个问题依旧存在.

  除了无连接, `HTTP`也是一个无状态的协议, 也就是服务器不会存储有关客户端的信息, 
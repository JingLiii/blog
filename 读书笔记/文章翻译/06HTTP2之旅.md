# HTTP/2之旅

> [Journey to HTTP/2](https://kamranahmed.info/blog/2016/08/13/http-in-depth/)

  距离我上一次通过博客写作以来, 经过了很长的一段安静的时间. 因为一直没有足够的时间投入其中. 直到现在有了一些空闲的时间, 我想利用他们写一些HTTP相关的文章.

  HTTP是一种协议, 每一个web开发者都应该知道他是如何推进整个网络的 并应该清楚的知道他是如何帮助你开发更好的应用.

## 什么是HTTP

  首先, 什么是HTTP? HTTP是一种基于`TCP/IP`的应用层的传输协议, 规定了客户端和服务器端如何进行通信的. 定义了在物联网中是请求和传送的内容. 对于应用层的协议, 我理解的只是一层抽象的协议, 让主机(客户端和服务器)之间的交流标准化, 并且依赖于`TCP/IP`来完成客户端之间的请求和响应.TCP默认使用`80`端口, 也可以使用其他的端口. HTTPS使用过的是`443`端口.

## `HTTP/0.9` 一个班机(开始的协议)(1991)

  第一个HTTP的版本是`HTTP/0.9`在1991年之前推出. 那是一种非常简单的协议, 含有一个简单的被称为`GET`的方法. 如果一个客户端通过访问服务器上的一些网页, 他会发出一个下面这种的简单请求.

```http
GET /index.html
```

  服务器返回的内容如下面展示的

```http
(response body)
(connection closed)
```

  这就是服务器获得的请求, 在响应中返回一个HTML, 只要内容开始传输, 那响应就会关闭. 他是

* 无头响应
* `GET`只是一个请求方法
* 响应一个HTML

  正如你看到的, 协议真的没什么, 除了作为未来发展的一个踏板.

## `HTTP/1.0`-1996

  在1996年, 下一个HTTP版本, 即`HTTP/1.0`版本被开发, 大大超过了上一个版本.

  不同于`HTTP/0.9`只能定义HTML响应, `HTTP/1.0`能够定义其他响应格式, 即图片, 视频文件, 普通文本和其他任何的内容类型. 他增加了更多的方法(即, `HEAD`和`POST`), 请求和响应的格式没有改变, HTTP头部可以在请求和响应都增加, 定义额外的状态码, 引入字符集的支持, 多部分类型, 作者, 缓存, 内容格式化并且支持更多

  下面是一个简单的`HTTP/1.0`的请求和响应看起来大概如此:

  ```http
  GET / HTTP/1.0
  Host: kamranahmed.info
  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS)
  Accept: */*
  ```

  正如你看到的, 通过这个请求, 客户端也可以发送他的个人信息, 支持的响应类型内容. 在`HTTP/0.9`中客户端并没有办法发送这些信息, 因为没有头部.

  对于上面的请求可能有如下的示例响应

  ```http
  HTTP / 1.0 200 OK
  Content-Type: text/plain
  Content-Length: 137582
  Expires: Thu, 05 Dec 1997 16:00:00 GMT
  Last-Modified: Wed, 5 August 1996 15:55:28 GMT
  Server: Apache 0.84

  (response body)
  (connection closed)
  ```

  每一个响应的开始都是`HTTP/1.0`(HTTP后面跟着的是版本号), 然后是状态码`200`, 后面跟着的事原因短语(如果你需要的话, 也可以是对于状态码的描述)

  在这个新的版本中, 请求和响应头, 依旧都是使用`ASCII`进行编码, 但是响应主体可以使用任何类型, 即, 图片, 视频, 普通文本和其他的任何内容类型. 所以, 现在服务器可以发送任何类型的响应给客户端; 在HTTP引入后不久, "超文本"一词, 在`HTTP`中变得并不适用. `HMTP`或者超媒体传输协议也许更加适用于场景, 但是, 我想, 我们还是坚持使用生命这个名字.

  `HTTP/1.0`一个主要的缺点是在每一个链接中使用不同的请求方式. 结果就是, 无论什么时候, 客户端都是为了从服务器获得一些东西, 他会打开一个新的TCP链接, 稍后一个简单的请求会完全使用这个链接. 然后这个链接就关闭了. 无论下一个请求是什么, 都会打开一个新的链接. 为什么坏呢? 很好, 让我们假设, 你浏览的网站有`10`张图片, `5`个样式文件, 和`5`个JavaScript文件, 当网页打开的时候, 需要一共进行20次请求. 因为请求一旦被满足, 服务器就会关闭链接. 将会有一系列独立的20个链接, 每个链接都在自己独立的链接上提供服务. 大量的链接导致严重的性能损失, 因为建立一个新的`TCP`造成明显的性能损失, 因为三次握手的建立启动非常慢.

### 三次握手 (Three-way Handshake)

  三次握手的简单建立过程: 所有的`TCP`链接都是通过三次握手开始的, 也就是客户端和服务器在发送应用数据之前, 发送一系列的数据包.

* `SYN` - 客户端挑选一个随机数, 我们称之为`x`, 然后发送给服务器端.
* `SYN ACK` - 服务器接收到请求之后, 发送一个`ACK`包返回给客户端, 也是一个随机的数字, 我们把服务器选出的数字称之为`y`, 并且和`x+1`, 这里的`x`是通过客户端发送给服务器的.
* `ACK` - 客户端将从服务器收到的数字`y`增加, 返回一个`ACK`的数据包, 包含一个数字`y+1`.

  一次完整的三次握手的过程就完成了, 客户端和服务器端的数据就可以开始传输了. 需要注意的是, 客户端一旦发送完最后一个`ACK`数据包, 就立即开始发送应用数据, 但是服务器端需要等到最后一个`ACK`包接受完成才会去响应请求.

  ![图片](http://i.imgur.com/uERG2G2.png)

> 需要注意, 这张图片有一个严重的问题, 最后一次通过客户端发送的数据包`ACK`, 这次握手应该只包括`y+1`, 也就是, 应该使用`ACK: Y+1`替代`ACK: x+1, y+1`

  然而, `HTTP / 1.0`的一些方案尝试通过增加一个请求头`Connection: keep-alive`去解决这个问题. 那意味着告诉服务器: "你好, 服务器, 不要关闭这个链接, 我还需要它", 但因为没有广泛使用, 所以这个问题依旧存在.

  除了无连接, `HTTP`也是一个无状态的协议, 也就是服务器不会存储有关客户端的信息, 所以每一个请求都必须含有服务器能够完成请求的独立信息, 和任何老的请求没有关系. 导致了, 大量分开的请求在客户端打卡的时候, 需要发送一些多余数据, 增加了网络带宽的使用.

## `HTTP / 1.1` - 1999

  仅仅3年, 就在1999年发布了下一个版本, `HTTP / 1.1`, 对上个版本进行了大幅改进. 对于`HTTP/1.0`的主要改进包括:

* **新的HTTP方法**增加了`PUT`, `PATCH`, 'OPTIONS', 'DELETE'
* **主机名表示**, 在`HTTP/1.0`中请求头中的`Host`并不是必须的, 但在`HTTP/1.1`就是必须的了.
* 上面提到的**持久链接**: 在`HTTP/1.0`中, 每个链接是唯一一个请求, 只要请求完成了, 就关闭了, 导致了严重的性能浪费和一些潜在的问题. `HTTP/1.1`引入了持久链接, 也就是**链接默认是不关闭的**, 会一直保持打开, 允许多个连续的请求. 可以利用请求头上的`Connection: close`关闭链接. 客户端通常在最后一次请求中发送这个请求头来关闭连接状态.
* 开始支持**管道流Pipelining**, 就是客户端可以发送多个请求到服务端, 不需要等待服务器在同一个连接上的响应, 并且服务器端在街道请求之后, 会遵循一样的顺序返回响应. 但是客户端如何知道这是第一个响应下载完成的点. 和下一个响应何时开始. 为了解决这个问题, 必须在头部使用`Content -Length`, 那可以让客户端区分出相应结束的地方, 并且可以开始等待下一个响应.

> * 应该注意的是, 为了从持续连接和管道流中获利, 响应中的`Content-Length`必须是可用的, 因为这可以让客户端知道传输完成, 并可以继续开始下一次请求(普通连续的请求方式)或者开始等待下一次响应(当管道流可以使用的时候)
> * 当这种方式依旧有个问题: 若数据是动态的, 服务器没有办法提前知道内容大小. 这种请求, 你的确不能使用持续连接. 为了解决这个问题, `HTTP/1.1`动态引入了动态编码. 在这种情况下, 服务器并不能通过分开编码省略内容长度. 然而, 如果这些方法都不能使用, 链接在最后一次请求后必须关闭.

* 当服务器并不能在传输开始的时候计算出`Content-Length`, 会对内容进行**分块传输**, 那意味着一块一块的发送数据, 并且对发送的每一个快添加一个`Content-Length`, 当所有数据块发送完成的时候, 也就是这次传输完成了, 就会发送一个空的数据块, 就是一个`Content-Lenght`是0的数据块, 标志这客户端的这次传输完成了. 为了标志出客户端的传输, 服务器端应该在请求头上添加一个`Transfer-Encoding: chunked`.
* 不像`HTTP/1.0`中只有一个基础的认证, `HTTP/1.1`A还包括了摘要和代理认证.
* 缓存
* 字节范围
* 字符集合
* 语言谈判(Language negotiation? 这特么是什么啊?)
* 客户端cookies
* 支持增强压缩
* 新的状态码
* 等等